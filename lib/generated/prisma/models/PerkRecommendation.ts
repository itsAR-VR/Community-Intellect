
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `PerkRecommendation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model PerkRecommendation
 * 
 */
export type PerkRecommendationModel = runtime.Types.Result.DefaultSelection<Prisma.$PerkRecommendationPayload>

export type AggregatePerkRecommendation = {
  _count: PerkRecommendationCountAggregateOutputType | null
  _avg: PerkRecommendationAvgAggregateOutputType | null
  _sum: PerkRecommendationSumAggregateOutputType | null
  _min: PerkRecommendationMinAggregateOutputType | null
  _max: PerkRecommendationMaxAggregateOutputType | null
}

export type PerkRecommendationAvgAggregateOutputType = {
  impactScore: number | null
}

export type PerkRecommendationSumAggregateOutputType = {
  impactScore: number | null
}

export type PerkRecommendationMinAggregateOutputType = {
  id: string | null
  tenantId: string | null
  memberId: string | null
  perkId: string | null
  rationale: string | null
  impactScore: number | null
  dismissed: boolean | null
  deliveredAt: Date | null
  createdAt: Date | null
}

export type PerkRecommendationMaxAggregateOutputType = {
  id: string | null
  tenantId: string | null
  memberId: string | null
  perkId: string | null
  rationale: string | null
  impactScore: number | null
  dismissed: boolean | null
  deliveredAt: Date | null
  createdAt: Date | null
}

export type PerkRecommendationCountAggregateOutputType = {
  id: number
  tenantId: number
  memberId: number
  perkId: number
  rationale: number
  impactScore: number
  matchingFactIds: number
  dismissed: number
  deliveredAt: number
  createdAt: number
  _all: number
}


export type PerkRecommendationAvgAggregateInputType = {
  impactScore?: true
}

export type PerkRecommendationSumAggregateInputType = {
  impactScore?: true
}

export type PerkRecommendationMinAggregateInputType = {
  id?: true
  tenantId?: true
  memberId?: true
  perkId?: true
  rationale?: true
  impactScore?: true
  dismissed?: true
  deliveredAt?: true
  createdAt?: true
}

export type PerkRecommendationMaxAggregateInputType = {
  id?: true
  tenantId?: true
  memberId?: true
  perkId?: true
  rationale?: true
  impactScore?: true
  dismissed?: true
  deliveredAt?: true
  createdAt?: true
}

export type PerkRecommendationCountAggregateInputType = {
  id?: true
  tenantId?: true
  memberId?: true
  perkId?: true
  rationale?: true
  impactScore?: true
  matchingFactIds?: true
  dismissed?: true
  deliveredAt?: true
  createdAt?: true
  _all?: true
}

export type PerkRecommendationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PerkRecommendation to aggregate.
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PerkRecommendations to fetch.
   */
  orderBy?: Prisma.PerkRecommendationOrderByWithRelationInput | Prisma.PerkRecommendationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PerkRecommendationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PerkRecommendations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PerkRecommendations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned PerkRecommendations
  **/
  _count?: true | PerkRecommendationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: PerkRecommendationAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: PerkRecommendationSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PerkRecommendationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PerkRecommendationMaxAggregateInputType
}

export type GetPerkRecommendationAggregateType<T extends PerkRecommendationAggregateArgs> = {
      [P in keyof T & keyof AggregatePerkRecommendation]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePerkRecommendation[P]>
    : Prisma.GetScalarType<T[P], AggregatePerkRecommendation[P]>
}




export type PerkRecommendationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PerkRecommendationWhereInput
  orderBy?: Prisma.PerkRecommendationOrderByWithAggregationInput | Prisma.PerkRecommendationOrderByWithAggregationInput[]
  by: Prisma.PerkRecommendationScalarFieldEnum[] | Prisma.PerkRecommendationScalarFieldEnum
  having?: Prisma.PerkRecommendationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PerkRecommendationCountAggregateInputType | true
  _avg?: PerkRecommendationAvgAggregateInputType
  _sum?: PerkRecommendationSumAggregateInputType
  _min?: PerkRecommendationMinAggregateInputType
  _max?: PerkRecommendationMaxAggregateInputType
}

export type PerkRecommendationGroupByOutputType = {
  id: string
  tenantId: string
  memberId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds: string[]
  dismissed: boolean
  deliveredAt: Date | null
  createdAt: Date
  _count: PerkRecommendationCountAggregateOutputType | null
  _avg: PerkRecommendationAvgAggregateOutputType | null
  _sum: PerkRecommendationSumAggregateOutputType | null
  _min: PerkRecommendationMinAggregateOutputType | null
  _max: PerkRecommendationMaxAggregateOutputType | null
}

type GetPerkRecommendationGroupByPayload<T extends PerkRecommendationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PerkRecommendationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PerkRecommendationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PerkRecommendationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PerkRecommendationGroupByOutputType[P]>
      }
    >
  >



export type PerkRecommendationWhereInput = {
  AND?: Prisma.PerkRecommendationWhereInput | Prisma.PerkRecommendationWhereInput[]
  OR?: Prisma.PerkRecommendationWhereInput[]
  NOT?: Prisma.PerkRecommendationWhereInput | Prisma.PerkRecommendationWhereInput[]
  id?: Prisma.StringFilter<"PerkRecommendation"> | string
  tenantId?: Prisma.StringFilter<"PerkRecommendation"> | string
  memberId?: Prisma.StringFilter<"PerkRecommendation"> | string
  perkId?: Prisma.StringFilter<"PerkRecommendation"> | string
  rationale?: Prisma.StringFilter<"PerkRecommendation"> | string
  impactScore?: Prisma.IntFilter<"PerkRecommendation"> | number
  matchingFactIds?: Prisma.StringNullableListFilter<"PerkRecommendation">
  dismissed?: Prisma.BoolFilter<"PerkRecommendation"> | boolean
  deliveredAt?: Prisma.DateTimeNullableFilter<"PerkRecommendation"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"PerkRecommendation"> | Date | string
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
  member?: Prisma.XOR<Prisma.MemberScalarRelationFilter, Prisma.MemberWhereInput>
  perk?: Prisma.XOR<Prisma.PerkScalarRelationFilter, Prisma.PerkWhereInput>
}

export type PerkRecommendationOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  perkId?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  impactScore?: Prisma.SortOrder
  matchingFactIds?: Prisma.SortOrder
  dismissed?: Prisma.SortOrder
  deliveredAt?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  tenant?: Prisma.TenantOrderByWithRelationInput
  member?: Prisma.MemberOrderByWithRelationInput
  perk?: Prisma.PerkOrderByWithRelationInput
}

export type PerkRecommendationWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.PerkRecommendationWhereInput | Prisma.PerkRecommendationWhereInput[]
  OR?: Prisma.PerkRecommendationWhereInput[]
  NOT?: Prisma.PerkRecommendationWhereInput | Prisma.PerkRecommendationWhereInput[]
  tenantId?: Prisma.StringFilter<"PerkRecommendation"> | string
  memberId?: Prisma.StringFilter<"PerkRecommendation"> | string
  perkId?: Prisma.StringFilter<"PerkRecommendation"> | string
  rationale?: Prisma.StringFilter<"PerkRecommendation"> | string
  impactScore?: Prisma.IntFilter<"PerkRecommendation"> | number
  matchingFactIds?: Prisma.StringNullableListFilter<"PerkRecommendation">
  dismissed?: Prisma.BoolFilter<"PerkRecommendation"> | boolean
  deliveredAt?: Prisma.DateTimeNullableFilter<"PerkRecommendation"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"PerkRecommendation"> | Date | string
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
  member?: Prisma.XOR<Prisma.MemberScalarRelationFilter, Prisma.MemberWhereInput>
  perk?: Prisma.XOR<Prisma.PerkScalarRelationFilter, Prisma.PerkWhereInput>
}, "id">

export type PerkRecommendationOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  perkId?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  impactScore?: Prisma.SortOrder
  matchingFactIds?: Prisma.SortOrder
  dismissed?: Prisma.SortOrder
  deliveredAt?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.PerkRecommendationCountOrderByAggregateInput
  _avg?: Prisma.PerkRecommendationAvgOrderByAggregateInput
  _max?: Prisma.PerkRecommendationMaxOrderByAggregateInput
  _min?: Prisma.PerkRecommendationMinOrderByAggregateInput
  _sum?: Prisma.PerkRecommendationSumOrderByAggregateInput
}

export type PerkRecommendationScalarWhereWithAggregatesInput = {
  AND?: Prisma.PerkRecommendationScalarWhereWithAggregatesInput | Prisma.PerkRecommendationScalarWhereWithAggregatesInput[]
  OR?: Prisma.PerkRecommendationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PerkRecommendationScalarWhereWithAggregatesInput | Prisma.PerkRecommendationScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"PerkRecommendation"> | string
  tenantId?: Prisma.StringWithAggregatesFilter<"PerkRecommendation"> | string
  memberId?: Prisma.StringWithAggregatesFilter<"PerkRecommendation"> | string
  perkId?: Prisma.StringWithAggregatesFilter<"PerkRecommendation"> | string
  rationale?: Prisma.StringWithAggregatesFilter<"PerkRecommendation"> | string
  impactScore?: Prisma.IntWithAggregatesFilter<"PerkRecommendation"> | number
  matchingFactIds?: Prisma.StringNullableListFilter<"PerkRecommendation">
  dismissed?: Prisma.BoolWithAggregatesFilter<"PerkRecommendation"> | boolean
  deliveredAt?: Prisma.DateTimeNullableWithAggregatesFilter<"PerkRecommendation"> | Date | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"PerkRecommendation"> | Date | string
}

export type PerkRecommendationCreateInput = {
  id: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutPerkRecommendationsInput
  member: Prisma.MemberCreateNestedOneWithoutPerkRecommendationsInput
  perk: Prisma.PerkCreateNestedOneWithoutRecommendationsInput
}

export type PerkRecommendationUncheckedCreateInput = {
  id: string
  tenantId: string
  memberId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutPerkRecommendationsNestedInput
  member?: Prisma.MemberUpdateOneRequiredWithoutPerkRecommendationsNestedInput
  perk?: Prisma.PerkUpdateOneRequiredWithoutRecommendationsNestedInput
}

export type PerkRecommendationUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  perkId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationCreateManyInput = {
  id: string
  tenantId: string
  memberId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  perkId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationListRelationFilter = {
  every?: Prisma.PerkRecommendationWhereInput
  some?: Prisma.PerkRecommendationWhereInput
  none?: Prisma.PerkRecommendationWhereInput
}

export type PerkRecommendationOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type PerkRecommendationCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  perkId?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  impactScore?: Prisma.SortOrder
  matchingFactIds?: Prisma.SortOrder
  dismissed?: Prisma.SortOrder
  deliveredAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type PerkRecommendationAvgOrderByAggregateInput = {
  impactScore?: Prisma.SortOrder
}

export type PerkRecommendationMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  perkId?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  impactScore?: Prisma.SortOrder
  dismissed?: Prisma.SortOrder
  deliveredAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type PerkRecommendationMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  perkId?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  impactScore?: Prisma.SortOrder
  dismissed?: Prisma.SortOrder
  deliveredAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type PerkRecommendationSumOrderByAggregateInput = {
  impactScore?: Prisma.SortOrder
}

export type PerkRecommendationCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutTenantInput, Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput> | Prisma.PerkRecommendationCreateWithoutTenantInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput | Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.PerkRecommendationCreateManyTenantInputEnvelope
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
}

export type PerkRecommendationUncheckedCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutTenantInput, Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput> | Prisma.PerkRecommendationCreateWithoutTenantInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput | Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.PerkRecommendationCreateManyTenantInputEnvelope
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
}

export type PerkRecommendationUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutTenantInput, Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput> | Prisma.PerkRecommendationCreateWithoutTenantInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput | Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutTenantInput | Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.PerkRecommendationCreateManyTenantInputEnvelope
  set?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  disconnect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  delete?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  update?: Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutTenantInput | Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.PerkRecommendationUpdateManyWithWhereWithoutTenantInput | Prisma.PerkRecommendationUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
}

export type PerkRecommendationUncheckedUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutTenantInput, Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput> | Prisma.PerkRecommendationCreateWithoutTenantInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput | Prisma.PerkRecommendationCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutTenantInput | Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.PerkRecommendationCreateManyTenantInputEnvelope
  set?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  disconnect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  delete?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  update?: Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutTenantInput | Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.PerkRecommendationUpdateManyWithWhereWithoutTenantInput | Prisma.PerkRecommendationUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
}

export type PerkRecommendationCreateNestedManyWithoutMemberInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutMemberInput, Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput> | Prisma.PerkRecommendationCreateWithoutMemberInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput | Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput[]
  createMany?: Prisma.PerkRecommendationCreateManyMemberInputEnvelope
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
}

export type PerkRecommendationUncheckedCreateNestedManyWithoutMemberInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutMemberInput, Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput> | Prisma.PerkRecommendationCreateWithoutMemberInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput | Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput[]
  createMany?: Prisma.PerkRecommendationCreateManyMemberInputEnvelope
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
}

export type PerkRecommendationUpdateManyWithoutMemberNestedInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutMemberInput, Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput> | Prisma.PerkRecommendationCreateWithoutMemberInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput | Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput[]
  upsert?: Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutMemberInput | Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutMemberInput[]
  createMany?: Prisma.PerkRecommendationCreateManyMemberInputEnvelope
  set?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  disconnect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  delete?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  update?: Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutMemberInput | Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutMemberInput[]
  updateMany?: Prisma.PerkRecommendationUpdateManyWithWhereWithoutMemberInput | Prisma.PerkRecommendationUpdateManyWithWhereWithoutMemberInput[]
  deleteMany?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
}

export type PerkRecommendationUncheckedUpdateManyWithoutMemberNestedInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutMemberInput, Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput> | Prisma.PerkRecommendationCreateWithoutMemberInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput | Prisma.PerkRecommendationCreateOrConnectWithoutMemberInput[]
  upsert?: Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutMemberInput | Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutMemberInput[]
  createMany?: Prisma.PerkRecommendationCreateManyMemberInputEnvelope
  set?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  disconnect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  delete?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  update?: Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutMemberInput | Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutMemberInput[]
  updateMany?: Prisma.PerkRecommendationUpdateManyWithWhereWithoutMemberInput | Prisma.PerkRecommendationUpdateManyWithWhereWithoutMemberInput[]
  deleteMany?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
}

export type PerkRecommendationCreateNestedManyWithoutPerkInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutPerkInput, Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput> | Prisma.PerkRecommendationCreateWithoutPerkInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput | Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput[]
  createMany?: Prisma.PerkRecommendationCreateManyPerkInputEnvelope
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
}

export type PerkRecommendationUncheckedCreateNestedManyWithoutPerkInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutPerkInput, Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput> | Prisma.PerkRecommendationCreateWithoutPerkInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput | Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput[]
  createMany?: Prisma.PerkRecommendationCreateManyPerkInputEnvelope
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
}

export type PerkRecommendationUpdateManyWithoutPerkNestedInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutPerkInput, Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput> | Prisma.PerkRecommendationCreateWithoutPerkInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput | Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput[]
  upsert?: Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutPerkInput | Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutPerkInput[]
  createMany?: Prisma.PerkRecommendationCreateManyPerkInputEnvelope
  set?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  disconnect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  delete?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  update?: Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutPerkInput | Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutPerkInput[]
  updateMany?: Prisma.PerkRecommendationUpdateManyWithWhereWithoutPerkInput | Prisma.PerkRecommendationUpdateManyWithWhereWithoutPerkInput[]
  deleteMany?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
}

export type PerkRecommendationUncheckedUpdateManyWithoutPerkNestedInput = {
  create?: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutPerkInput, Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput> | Prisma.PerkRecommendationCreateWithoutPerkInput[] | Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput[]
  connectOrCreate?: Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput | Prisma.PerkRecommendationCreateOrConnectWithoutPerkInput[]
  upsert?: Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutPerkInput | Prisma.PerkRecommendationUpsertWithWhereUniqueWithoutPerkInput[]
  createMany?: Prisma.PerkRecommendationCreateManyPerkInputEnvelope
  set?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  disconnect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  delete?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  connect?: Prisma.PerkRecommendationWhereUniqueInput | Prisma.PerkRecommendationWhereUniqueInput[]
  update?: Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutPerkInput | Prisma.PerkRecommendationUpdateWithWhereUniqueWithoutPerkInput[]
  updateMany?: Prisma.PerkRecommendationUpdateManyWithWhereWithoutPerkInput | Prisma.PerkRecommendationUpdateManyWithWhereWithoutPerkInput[]
  deleteMany?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
}

export type PerkRecommendationCreatematchingFactIdsInput = {
  set: string[]
}

export type PerkRecommendationUpdatematchingFactIdsInput = {
  set?: string[]
  push?: string | string[]
}

export type PerkRecommendationCreateWithoutTenantInput = {
  id: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
  member: Prisma.MemberCreateNestedOneWithoutPerkRecommendationsInput
  perk: Prisma.PerkCreateNestedOneWithoutRecommendationsInput
}

export type PerkRecommendationUncheckedCreateWithoutTenantInput = {
  id: string
  memberId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationCreateOrConnectWithoutTenantInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  create: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutTenantInput, Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput>
}

export type PerkRecommendationCreateManyTenantInputEnvelope = {
  data: Prisma.PerkRecommendationCreateManyTenantInput | Prisma.PerkRecommendationCreateManyTenantInput[]
  skipDuplicates?: boolean
}

export type PerkRecommendationUpsertWithWhereUniqueWithoutTenantInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  update: Prisma.XOR<Prisma.PerkRecommendationUpdateWithoutTenantInput, Prisma.PerkRecommendationUncheckedUpdateWithoutTenantInput>
  create: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutTenantInput, Prisma.PerkRecommendationUncheckedCreateWithoutTenantInput>
}

export type PerkRecommendationUpdateWithWhereUniqueWithoutTenantInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateWithoutTenantInput, Prisma.PerkRecommendationUncheckedUpdateWithoutTenantInput>
}

export type PerkRecommendationUpdateManyWithWhereWithoutTenantInput = {
  where: Prisma.PerkRecommendationScalarWhereInput
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateManyMutationInput, Prisma.PerkRecommendationUncheckedUpdateManyWithoutTenantInput>
}

export type PerkRecommendationScalarWhereInput = {
  AND?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
  OR?: Prisma.PerkRecommendationScalarWhereInput[]
  NOT?: Prisma.PerkRecommendationScalarWhereInput | Prisma.PerkRecommendationScalarWhereInput[]
  id?: Prisma.StringFilter<"PerkRecommendation"> | string
  tenantId?: Prisma.StringFilter<"PerkRecommendation"> | string
  memberId?: Prisma.StringFilter<"PerkRecommendation"> | string
  perkId?: Prisma.StringFilter<"PerkRecommendation"> | string
  rationale?: Prisma.StringFilter<"PerkRecommendation"> | string
  impactScore?: Prisma.IntFilter<"PerkRecommendation"> | number
  matchingFactIds?: Prisma.StringNullableListFilter<"PerkRecommendation">
  dismissed?: Prisma.BoolFilter<"PerkRecommendation"> | boolean
  deliveredAt?: Prisma.DateTimeNullableFilter<"PerkRecommendation"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"PerkRecommendation"> | Date | string
}

export type PerkRecommendationCreateWithoutMemberInput = {
  id: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutPerkRecommendationsInput
  perk: Prisma.PerkCreateNestedOneWithoutRecommendationsInput
}

export type PerkRecommendationUncheckedCreateWithoutMemberInput = {
  id: string
  tenantId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationCreateOrConnectWithoutMemberInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  create: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutMemberInput, Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput>
}

export type PerkRecommendationCreateManyMemberInputEnvelope = {
  data: Prisma.PerkRecommendationCreateManyMemberInput | Prisma.PerkRecommendationCreateManyMemberInput[]
  skipDuplicates?: boolean
}

export type PerkRecommendationUpsertWithWhereUniqueWithoutMemberInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  update: Prisma.XOR<Prisma.PerkRecommendationUpdateWithoutMemberInput, Prisma.PerkRecommendationUncheckedUpdateWithoutMemberInput>
  create: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutMemberInput, Prisma.PerkRecommendationUncheckedCreateWithoutMemberInput>
}

export type PerkRecommendationUpdateWithWhereUniqueWithoutMemberInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateWithoutMemberInput, Prisma.PerkRecommendationUncheckedUpdateWithoutMemberInput>
}

export type PerkRecommendationUpdateManyWithWhereWithoutMemberInput = {
  where: Prisma.PerkRecommendationScalarWhereInput
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateManyMutationInput, Prisma.PerkRecommendationUncheckedUpdateManyWithoutMemberInput>
}

export type PerkRecommendationCreateWithoutPerkInput = {
  id: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutPerkRecommendationsInput
  member: Prisma.MemberCreateNestedOneWithoutPerkRecommendationsInput
}

export type PerkRecommendationUncheckedCreateWithoutPerkInput = {
  id: string
  tenantId: string
  memberId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationCreateOrConnectWithoutPerkInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  create: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutPerkInput, Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput>
}

export type PerkRecommendationCreateManyPerkInputEnvelope = {
  data: Prisma.PerkRecommendationCreateManyPerkInput | Prisma.PerkRecommendationCreateManyPerkInput[]
  skipDuplicates?: boolean
}

export type PerkRecommendationUpsertWithWhereUniqueWithoutPerkInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  update: Prisma.XOR<Prisma.PerkRecommendationUpdateWithoutPerkInput, Prisma.PerkRecommendationUncheckedUpdateWithoutPerkInput>
  create: Prisma.XOR<Prisma.PerkRecommendationCreateWithoutPerkInput, Prisma.PerkRecommendationUncheckedCreateWithoutPerkInput>
}

export type PerkRecommendationUpdateWithWhereUniqueWithoutPerkInput = {
  where: Prisma.PerkRecommendationWhereUniqueInput
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateWithoutPerkInput, Prisma.PerkRecommendationUncheckedUpdateWithoutPerkInput>
}

export type PerkRecommendationUpdateManyWithWhereWithoutPerkInput = {
  where: Prisma.PerkRecommendationScalarWhereInput
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateManyMutationInput, Prisma.PerkRecommendationUncheckedUpdateManyWithoutPerkInput>
}

export type PerkRecommendationCreateManyTenantInput = {
  id: string
  memberId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  member?: Prisma.MemberUpdateOneRequiredWithoutPerkRecommendationsNestedInput
  perk?: Prisma.PerkUpdateOneRequiredWithoutRecommendationsNestedInput
}

export type PerkRecommendationUncheckedUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  perkId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationUncheckedUpdateManyWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  perkId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationCreateManyMemberInput = {
  id: string
  tenantId: string
  perkId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationUpdateWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutPerkRecommendationsNestedInput
  perk?: Prisma.PerkUpdateOneRequiredWithoutRecommendationsNestedInput
}

export type PerkRecommendationUncheckedUpdateWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  perkId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationUncheckedUpdateManyWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  perkId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationCreateManyPerkInput = {
  id: string
  tenantId: string
  memberId: string
  rationale: string
  impactScore: number
  matchingFactIds?: Prisma.PerkRecommendationCreatematchingFactIdsInput | string[]
  dismissed?: boolean
  deliveredAt?: Date | string | null
  createdAt?: Date | string
}

export type PerkRecommendationUpdateWithoutPerkInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutPerkRecommendationsNestedInput
  member?: Prisma.MemberUpdateOneRequiredWithoutPerkRecommendationsNestedInput
}

export type PerkRecommendationUncheckedUpdateWithoutPerkInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PerkRecommendationUncheckedUpdateManyWithoutPerkInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  impactScore?: Prisma.IntFieldUpdateOperationsInput | number
  matchingFactIds?: Prisma.PerkRecommendationUpdatematchingFactIdsInput | string[]
  dismissed?: Prisma.BoolFieldUpdateOperationsInput | boolean
  deliveredAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type PerkRecommendationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  memberId?: boolean
  perkId?: boolean
  rationale?: boolean
  impactScore?: boolean
  matchingFactIds?: boolean
  dismissed?: boolean
  deliveredAt?: boolean
  createdAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  member?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  perk?: boolean | Prisma.PerkDefaultArgs<ExtArgs>
}, ExtArgs["result"]["perkRecommendation"]>

export type PerkRecommendationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  memberId?: boolean
  perkId?: boolean
  rationale?: boolean
  impactScore?: boolean
  matchingFactIds?: boolean
  dismissed?: boolean
  deliveredAt?: boolean
  createdAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  member?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  perk?: boolean | Prisma.PerkDefaultArgs<ExtArgs>
}, ExtArgs["result"]["perkRecommendation"]>

export type PerkRecommendationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  memberId?: boolean
  perkId?: boolean
  rationale?: boolean
  impactScore?: boolean
  matchingFactIds?: boolean
  dismissed?: boolean
  deliveredAt?: boolean
  createdAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  member?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  perk?: boolean | Prisma.PerkDefaultArgs<ExtArgs>
}, ExtArgs["result"]["perkRecommendation"]>

export type PerkRecommendationSelectScalar = {
  id?: boolean
  tenantId?: boolean
  memberId?: boolean
  perkId?: boolean
  rationale?: boolean
  impactScore?: boolean
  matchingFactIds?: boolean
  dismissed?: boolean
  deliveredAt?: boolean
  createdAt?: boolean
}

export type PerkRecommendationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "tenantId" | "memberId" | "perkId" | "rationale" | "impactScore" | "matchingFactIds" | "dismissed" | "deliveredAt" | "createdAt", ExtArgs["result"]["perkRecommendation"]>
export type PerkRecommendationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  member?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  perk?: boolean | Prisma.PerkDefaultArgs<ExtArgs>
}
export type PerkRecommendationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  member?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  perk?: boolean | Prisma.PerkDefaultArgs<ExtArgs>
}
export type PerkRecommendationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  member?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  perk?: boolean | Prisma.PerkDefaultArgs<ExtArgs>
}

export type $PerkRecommendationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "PerkRecommendation"
  objects: {
    tenant: Prisma.$TenantPayload<ExtArgs>
    member: Prisma.$MemberPayload<ExtArgs>
    perk: Prisma.$PerkPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    tenantId: string
    memberId: string
    perkId: string
    rationale: string
    impactScore: number
    matchingFactIds: string[]
    dismissed: boolean
    deliveredAt: Date | null
    createdAt: Date
  }, ExtArgs["result"]["perkRecommendation"]>
  composites: {}
}

export type PerkRecommendationGetPayload<S extends boolean | null | undefined | PerkRecommendationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload, S>

export type PerkRecommendationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PerkRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PerkRecommendationCountAggregateInputType | true
  }

export interface PerkRecommendationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerkRecommendation'], meta: { name: 'PerkRecommendation' } }
  /**
   * Find zero or one PerkRecommendation that matches the filter.
   * @param {PerkRecommendationFindUniqueArgs} args - Arguments to find a PerkRecommendation
   * @example
   * // Get one PerkRecommendation
   * const perkRecommendation = await prisma.perkRecommendation.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PerkRecommendationFindUniqueArgs>(args: Prisma.SelectSubset<T, PerkRecommendationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one PerkRecommendation that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PerkRecommendationFindUniqueOrThrowArgs} args - Arguments to find a PerkRecommendation
   * @example
   * // Get one PerkRecommendation
   * const perkRecommendation = await prisma.perkRecommendation.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PerkRecommendationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PerkRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PerkRecommendation that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationFindFirstArgs} args - Arguments to find a PerkRecommendation
   * @example
   * // Get one PerkRecommendation
   * const perkRecommendation = await prisma.perkRecommendation.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PerkRecommendationFindFirstArgs>(args?: Prisma.SelectSubset<T, PerkRecommendationFindFirstArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PerkRecommendation that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationFindFirstOrThrowArgs} args - Arguments to find a PerkRecommendation
   * @example
   * // Get one PerkRecommendation
   * const perkRecommendation = await prisma.perkRecommendation.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PerkRecommendationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PerkRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more PerkRecommendations that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all PerkRecommendations
   * const perkRecommendations = await prisma.perkRecommendation.findMany()
   * 
   * // Get first 10 PerkRecommendations
   * const perkRecommendations = await prisma.perkRecommendation.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const perkRecommendationWithIdOnly = await prisma.perkRecommendation.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends PerkRecommendationFindManyArgs>(args?: Prisma.SelectSubset<T, PerkRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a PerkRecommendation.
   * @param {PerkRecommendationCreateArgs} args - Arguments to create a PerkRecommendation.
   * @example
   * // Create one PerkRecommendation
   * const PerkRecommendation = await prisma.perkRecommendation.create({
   *   data: {
   *     // ... data to create a PerkRecommendation
   *   }
   * })
   * 
   */
  create<T extends PerkRecommendationCreateArgs>(args: Prisma.SelectSubset<T, PerkRecommendationCreateArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many PerkRecommendations.
   * @param {PerkRecommendationCreateManyArgs} args - Arguments to create many PerkRecommendations.
   * @example
   * // Create many PerkRecommendations
   * const perkRecommendation = await prisma.perkRecommendation.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PerkRecommendationCreateManyArgs>(args?: Prisma.SelectSubset<T, PerkRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many PerkRecommendations and returns the data saved in the database.
   * @param {PerkRecommendationCreateManyAndReturnArgs} args - Arguments to create many PerkRecommendations.
   * @example
   * // Create many PerkRecommendations
   * const perkRecommendation = await prisma.perkRecommendation.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many PerkRecommendations and only return the `id`
   * const perkRecommendationWithIdOnly = await prisma.perkRecommendation.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PerkRecommendationCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PerkRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a PerkRecommendation.
   * @param {PerkRecommendationDeleteArgs} args - Arguments to delete one PerkRecommendation.
   * @example
   * // Delete one PerkRecommendation
   * const PerkRecommendation = await prisma.perkRecommendation.delete({
   *   where: {
   *     // ... filter to delete one PerkRecommendation
   *   }
   * })
   * 
   */
  delete<T extends PerkRecommendationDeleteArgs>(args: Prisma.SelectSubset<T, PerkRecommendationDeleteArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one PerkRecommendation.
   * @param {PerkRecommendationUpdateArgs} args - Arguments to update one PerkRecommendation.
   * @example
   * // Update one PerkRecommendation
   * const perkRecommendation = await prisma.perkRecommendation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PerkRecommendationUpdateArgs>(args: Prisma.SelectSubset<T, PerkRecommendationUpdateArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more PerkRecommendations.
   * @param {PerkRecommendationDeleteManyArgs} args - Arguments to filter PerkRecommendations to delete.
   * @example
   * // Delete a few PerkRecommendations
   * const { count } = await prisma.perkRecommendation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PerkRecommendationDeleteManyArgs>(args?: Prisma.SelectSubset<T, PerkRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PerkRecommendations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many PerkRecommendations
   * const perkRecommendation = await prisma.perkRecommendation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PerkRecommendationUpdateManyArgs>(args: Prisma.SelectSubset<T, PerkRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PerkRecommendations and returns the data updated in the database.
   * @param {PerkRecommendationUpdateManyAndReturnArgs} args - Arguments to update many PerkRecommendations.
   * @example
   * // Update many PerkRecommendations
   * const perkRecommendation = await prisma.perkRecommendation.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more PerkRecommendations and only return the `id`
   * const perkRecommendationWithIdOnly = await prisma.perkRecommendation.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PerkRecommendationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PerkRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one PerkRecommendation.
   * @param {PerkRecommendationUpsertArgs} args - Arguments to update or create a PerkRecommendation.
   * @example
   * // Update or create a PerkRecommendation
   * const perkRecommendation = await prisma.perkRecommendation.upsert({
   *   create: {
   *     // ... data to create a PerkRecommendation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the PerkRecommendation we want to update
   *   }
   * })
   */
  upsert<T extends PerkRecommendationUpsertArgs>(args: Prisma.SelectSubset<T, PerkRecommendationUpsertArgs<ExtArgs>>): Prisma.Prisma__PerkRecommendationClient<runtime.Types.Result.GetResult<Prisma.$PerkRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of PerkRecommendations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationCountArgs} args - Arguments to filter PerkRecommendations to count.
   * @example
   * // Count the number of PerkRecommendations
   * const count = await prisma.perkRecommendation.count({
   *   where: {
   *     // ... the filter for the PerkRecommendations we want to count
   *   }
   * })
  **/
  count<T extends PerkRecommendationCountArgs>(
    args?: Prisma.Subset<T, PerkRecommendationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PerkRecommendationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a PerkRecommendation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PerkRecommendationAggregateArgs>(args: Prisma.Subset<T, PerkRecommendationAggregateArgs>): Prisma.PrismaPromise<GetPerkRecommendationAggregateType<T>>

  /**
   * Group by PerkRecommendation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PerkRecommendationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PerkRecommendationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PerkRecommendationGroupByArgs['orderBy'] }
      : { orderBy?: PerkRecommendationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PerkRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerkRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the PerkRecommendation model
 */
readonly fields: PerkRecommendationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for PerkRecommendation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PerkRecommendationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  tenant<T extends Prisma.TenantDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TenantDefaultArgs<ExtArgs>>): Prisma.Prisma__TenantClient<runtime.Types.Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  member<T extends Prisma.MemberDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MemberDefaultArgs<ExtArgs>>): Prisma.Prisma__MemberClient<runtime.Types.Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  perk<T extends Prisma.PerkDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PerkDefaultArgs<ExtArgs>>): Prisma.Prisma__PerkClient<runtime.Types.Result.GetResult<Prisma.$PerkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the PerkRecommendation model
 */
export interface PerkRecommendationFieldRefs {
  readonly id: Prisma.FieldRef<"PerkRecommendation", 'String'>
  readonly tenantId: Prisma.FieldRef<"PerkRecommendation", 'String'>
  readonly memberId: Prisma.FieldRef<"PerkRecommendation", 'String'>
  readonly perkId: Prisma.FieldRef<"PerkRecommendation", 'String'>
  readonly rationale: Prisma.FieldRef<"PerkRecommendation", 'String'>
  readonly impactScore: Prisma.FieldRef<"PerkRecommendation", 'Int'>
  readonly matchingFactIds: Prisma.FieldRef<"PerkRecommendation", 'String[]'>
  readonly dismissed: Prisma.FieldRef<"PerkRecommendation", 'Boolean'>
  readonly deliveredAt: Prisma.FieldRef<"PerkRecommendation", 'DateTime'>
  readonly createdAt: Prisma.FieldRef<"PerkRecommendation", 'DateTime'>
}
    

// Custom InputTypes
/**
 * PerkRecommendation findUnique
 */
export type PerkRecommendationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * Filter, which PerkRecommendation to fetch.
   */
  where: Prisma.PerkRecommendationWhereUniqueInput
}

/**
 * PerkRecommendation findUniqueOrThrow
 */
export type PerkRecommendationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * Filter, which PerkRecommendation to fetch.
   */
  where: Prisma.PerkRecommendationWhereUniqueInput
}

/**
 * PerkRecommendation findFirst
 */
export type PerkRecommendationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * Filter, which PerkRecommendation to fetch.
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PerkRecommendations to fetch.
   */
  orderBy?: Prisma.PerkRecommendationOrderByWithRelationInput | Prisma.PerkRecommendationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PerkRecommendations.
   */
  cursor?: Prisma.PerkRecommendationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PerkRecommendations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PerkRecommendations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PerkRecommendations.
   */
  distinct?: Prisma.PerkRecommendationScalarFieldEnum | Prisma.PerkRecommendationScalarFieldEnum[]
}

/**
 * PerkRecommendation findFirstOrThrow
 */
export type PerkRecommendationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * Filter, which PerkRecommendation to fetch.
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PerkRecommendations to fetch.
   */
  orderBy?: Prisma.PerkRecommendationOrderByWithRelationInput | Prisma.PerkRecommendationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PerkRecommendations.
   */
  cursor?: Prisma.PerkRecommendationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PerkRecommendations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PerkRecommendations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PerkRecommendations.
   */
  distinct?: Prisma.PerkRecommendationScalarFieldEnum | Prisma.PerkRecommendationScalarFieldEnum[]
}

/**
 * PerkRecommendation findMany
 */
export type PerkRecommendationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * Filter, which PerkRecommendations to fetch.
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PerkRecommendations to fetch.
   */
  orderBy?: Prisma.PerkRecommendationOrderByWithRelationInput | Prisma.PerkRecommendationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing PerkRecommendations.
   */
  cursor?: Prisma.PerkRecommendationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PerkRecommendations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PerkRecommendations.
   */
  skip?: number
  distinct?: Prisma.PerkRecommendationScalarFieldEnum | Prisma.PerkRecommendationScalarFieldEnum[]
}

/**
 * PerkRecommendation create
 */
export type PerkRecommendationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * The data needed to create a PerkRecommendation.
   */
  data: Prisma.XOR<Prisma.PerkRecommendationCreateInput, Prisma.PerkRecommendationUncheckedCreateInput>
}

/**
 * PerkRecommendation createMany
 */
export type PerkRecommendationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many PerkRecommendations.
   */
  data: Prisma.PerkRecommendationCreateManyInput | Prisma.PerkRecommendationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * PerkRecommendation createManyAndReturn
 */
export type PerkRecommendationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * The data used to create many PerkRecommendations.
   */
  data: Prisma.PerkRecommendationCreateManyInput | Prisma.PerkRecommendationCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * PerkRecommendation update
 */
export type PerkRecommendationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * The data needed to update a PerkRecommendation.
   */
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateInput, Prisma.PerkRecommendationUncheckedUpdateInput>
  /**
   * Choose, which PerkRecommendation to update.
   */
  where: Prisma.PerkRecommendationWhereUniqueInput
}

/**
 * PerkRecommendation updateMany
 */
export type PerkRecommendationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update PerkRecommendations.
   */
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateManyMutationInput, Prisma.PerkRecommendationUncheckedUpdateManyInput>
  /**
   * Filter which PerkRecommendations to update
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * Limit how many PerkRecommendations to update.
   */
  limit?: number
}

/**
 * PerkRecommendation updateManyAndReturn
 */
export type PerkRecommendationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * The data used to update PerkRecommendations.
   */
  data: Prisma.XOR<Prisma.PerkRecommendationUpdateManyMutationInput, Prisma.PerkRecommendationUncheckedUpdateManyInput>
  /**
   * Filter which PerkRecommendations to update
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * Limit how many PerkRecommendations to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * PerkRecommendation upsert
 */
export type PerkRecommendationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * The filter to search for the PerkRecommendation to update in case it exists.
   */
  where: Prisma.PerkRecommendationWhereUniqueInput
  /**
   * In case the PerkRecommendation found by the `where` argument doesn't exist, create a new PerkRecommendation with this data.
   */
  create: Prisma.XOR<Prisma.PerkRecommendationCreateInput, Prisma.PerkRecommendationUncheckedCreateInput>
  /**
   * In case the PerkRecommendation was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PerkRecommendationUpdateInput, Prisma.PerkRecommendationUncheckedUpdateInput>
}

/**
 * PerkRecommendation delete
 */
export type PerkRecommendationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
  /**
   * Filter which PerkRecommendation to delete.
   */
  where: Prisma.PerkRecommendationWhereUniqueInput
}

/**
 * PerkRecommendation deleteMany
 */
export type PerkRecommendationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PerkRecommendations to delete
   */
  where?: Prisma.PerkRecommendationWhereInput
  /**
   * Limit how many PerkRecommendations to delete.
   */
  limit?: number
}

/**
 * PerkRecommendation without action
 */
export type PerkRecommendationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PerkRecommendation
   */
  select?: Prisma.PerkRecommendationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PerkRecommendation
   */
  omit?: Prisma.PerkRecommendationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PerkRecommendationInclude<ExtArgs> | null
}
